<html>

<head>
    <title>main</title>
</head>

<body>
    <canvas id="myCanvas" width="800" height="800"></canvas>
    <script src="Perlin.js"></script>
    <script src="TreeBuilder.js"></script>
    <script type="module">
        import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
        import { PointerLockControls } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/controls/PointerLockControls.js';












        let treePositions = [];
        var scene = new THREE.Scene();
        let raycaster = new THREE.Raycaster();

        let trees = [];
        let collision = [];
        let change = 0;
        let sinwave = 0;
        let displacement = 0;
        let moving = false;


        const spheres = [];
        const spheresIndex = 0;
        let worldItems = [];
        let intersection = null;
        let toggle = 0;
        let clock = new THREE.Clock();
        let turnSpeed = .1;


        let prevTime = performance.now();


        let sunColors = [0xf7e2ba, 0xffdaa8, 0xf8cb7c, 0xfdb25b, 0xfa9e4d];
        let moonColor = [0xdde2e5];
        let skyColors = [0x000608, 0x072f41, 0x094f6d, 0x436e91, 0x5e88b8, 0x7998bb];
        let windowWidth = window.innerWidth;
        let windowHeight = window.innerHeight;
        let yheight;

        const loader = new THREE.TextureLoader();

        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.lookAt(new THREE.Vector3(0.0, 0.0, 0.0));
        camera.position.set(0, 80, 10);
        scene.add(camera);

        let previousTime = performance.now();

        var renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
        renderer.setClearColor(0xADD8E6);
        // If you want this to span the window, instead of using the myCanvas object, use the window object
        renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);
        // If you want the render to span the window, uncomment this
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        //        renderer.shadowMap.type = THREE.BasicShadowMap;
        renderer.shadowMapSoft = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        var controls = new PointerLockControls(camera, document.body);
        document.addEventListener('click', function () {
            controls.lock();
        });


        const cursorGeom = new THREE.SphereGeometry(0.02, 16, 16);
        const cursorMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const cursor = new THREE.Mesh(cursorGeom, cursorMat);
        scene.add(cursor);
        spheres.push(cursor);

        var world = new THREE.BoxGeometry(900, 900, 900);
        var wmat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: false, side: THREE.DoubleSide });
        /* Cause the material to be visible for inside and outside */
        wmat.side = THREE.BackSide;
        var cube = new THREE.Mesh(world, wmat);
        scene.add(cube);
        worldItems.push(cube);


        function makeLights(hexCode, x, y, z, intensity) {
            //Creates a sphere and pointlight and adds them both to the scene
            renderer.setClearColor(0x000608);
            this.bulbGeometry = new THREE.SphereGeometry(10, 32, 16);
            this.bulbLight = new THREE.PointLight(hexCode, intensity, 20000); //Creates point light
            //color of the light being directed
            this.bulbMat = new THREE.MeshPhongMaterial({ //Creates bulb material for the light
                emissive: hexCode, //color of the bulb
                emissiveIntensity: 1,
                color: 0xffff00
            });
            this.bulbLight.add(new THREE.Mesh(this.bulbGeometry, this.bulbMat)); //Adds bulb geometry and bulb light to the point light
            this.bulbLight.position.set(x, y, z); //Positions the bulblight 
            this.bulbLight.castShadow = true; //Casts shadow from the bulb light
            this.bulbLight.shadow.bias = - 0.0005; // reduces self-shadowing on double-sided objects
            //  this.bulbLight.shadow.bias = - 0.0005; // reduces self-shadowing on double-sided objects
            this.bulbLight.shadow.radius = 8;
            this.bulbLight.shadow.mapSize.width = 2048; // You have there 4K no need to go over 2K
            this.bulbLight.shadow.mapSize.height = 2048; // 
            // this.bulbLight.shadow.mapSize.width = 2048;
            // this.bulbLight.shadow.mapSize.height = 2048;
            scene.add(this.bulbLight); //Adds bulb light to the scene
        }

        let moon = new makeLights(moonColor[0], -255, -255, 0, .1);
        let sun = new makeLights(sunColors[4], 255, 255, 0, 1);
        worldItems.push(sun.bulbLight);
        worldItems.push(moon.bulbLight);





        var waterGeom = new THREE.PlaneBufferGeometry(800, 800, 256, 256);
        var waterMat = new THREE.MeshPhysicalMaterial({ map: loader.load('land/water4.jpg') });
        var water = new THREE.Mesh(waterGeom, waterMat);
        water.rotation.x = -Math.PI / 2;
        water.position.y = -25;
        //water.receiveShadow = true;
        scene.add(water);
        worldItems.push(water);



        var terrainGeom = new THREE.PlaneBufferGeometry(800, 800, 256, 256);
        var terrainMat = new THREE.MeshPhysicalMaterial({ map: loader.load('land/sand3.jpg'), side: THREE.DoubleSide });
        var terrain = new THREE.Mesh(terrainGeom, terrainMat);
        terrain.rotation.x = -Math.PI / 2;
        scene.add(terrain);


        var peak = 60;
        var vertices = terrain.geometry.attributes.position.array;
        for (var i = 0; i <= vertices.length; i += 3) {
            vertices[i + 2] = peak * Math.random();
        }
        terrain.geometry.attributes.position.needsUpdate = true;
        terrain.geometry.computeVertexNormals();


        //makes shadows not completely opaque. but the plane itself does not receive/cast shadow
        let terrainShadowMat = new THREE.ShadowMaterial();
        terrainShadowMat.opacity = 0.5;
        var terrainShadow = new THREE.Mesh(terrainGeom, terrainShadowMat);
        terrainShadow.receiveShadow = true;
        terrainShadow.position.copy(terrain.position);
        terrainShadow.rotation.copy(terrain.rotation);
        scene.add(terrainShadow);


        //makes shadows not completely opaque. but the plane itself does not receive/cast shadow
        let waterShadowMat = new THREE.ShadowMaterial();
        waterShadowMat.opacity = 0.5;
        var waterShadow = new THREE.Mesh(waterGeom, waterShadowMat);
        waterShadow.receiveShadow = true;
        waterShadow.position.copy(water.position);
        waterShadow.rotation.copy(water.rotation);
        scene.add(waterShadow);


        var perlin = new Perlin();
        var peak = 20;
        var smoothing = 300;
        var vertices = terrain.geometry.attributes.position.array;
        for (var i = 0; i <= vertices.length; i += 3) {
            vertices[i + 2] = peak * perlin.noise(
                vertices[i] / smoothing,
                vertices[i + 1] / smoothing
            );
        }
        terrain.geometry.attributes.position.needsUpdate = true;
        terrain.geometry.computeVertexNormals();


        terrain.castShadow = true;
        // plane.receiveShadow = true;
        worldItems.push(terrain);



        //This function randomly returns a true or false value or a number between 0 and 10 in order to help randomize certain customizations
        function random() {
            let randomNumber = Math.round(Math.random() * 10); //Creates a random number between 0 and 10
            if (randomNumber % 2 == 0) { //If the random number is even
                return true;
            }
            else {
                return false;
            }
        }




        function TreeBuilder(string, params) {
            this.string = string;
            this.params = params;

            this.build = function () {
                //init params
                var state = {
                    bRadius: this.params.branchRadius,
                    bLength: this.params.branchLength,
                    bReduction: this.params.branchReduction,
                    bMinRadius: this.params.branchMinRadius,
                    position: new THREE.Vector3(0, 0, 0),
                    rotation: new THREE.Quaternion()
                }
                var stateStack = [];

                //init object
                var tree = new THREE.Object3D();
                //var textureLoader = new THREE.TextureLoader();
                var branchMaterial = new THREE.MeshPhongMaterial({ color: 0x964B00 });
                var appleMaterial = new THREE.MeshPhongMaterial({ color: 0xf83782 });
                // var branchMaterial = new THREE.MeshBasicMaterial({ color: 'brown', map: textureLoader.load("textures/branch.jpg") });
                // var appleMaterial = new THREE.MeshBasicMaterial({ color: 'red', map: textureLoader.load("textures/apple.jpg") });

                for (var i = 0; i < this.string.length; i++) {
                    var char = this.string.charAt(i);
                    if (char == "F") {
                        tree.add(buildBranch(state, branchMaterial));
                    }
                    if (char == "X") {
                        tree.add(buildLeaf(state, appleMaterial));
                    }
                    if (char == "+") {
                        state.rotation.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), this.params.delta * Math.PI / 180));
                    }
                    if (char == "-") {
                        state.rotation.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), -this.params.delta * Math.PI / 180));
                    }
                    if (char == "&") {
                        state.rotation.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), -this.params.delta * Math.PI / 180));
                    }
                    if (char == "^") {
                        state.rotation.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), this.params.delta * Math.PI / 180));
                    }
                    if (char == "<") {
                        state.rotation.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -this.params.delta * Math.PI / 180));
                    }
                    if (char == ">") {
                        state.rotation.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), this.params.delta * Math.PI / 180));
                    }
                    if (char == "[") {
                        stateStack.push(cloneState(state));
                        state.bRadius = (state.bRadius - state.bReduction) > state.bMinRadius ? (state.bRadius - state.bReduction) : state.bRadius;
                    }
                    if (char == "]") {
                        state = cloneState(stateStack.pop());
                    }

                }
                tree.castShadow = true;
                return tree;
            }

        }

        function buildBranch(state, material) {
            var transform = new THREE.Quaternion();
            transform.multiply(state.rotation);

            var position = new THREE.Vector3(0.0, state.bLength / 2, 0.0);
            position.applyQuaternion(state.rotation);
            state.position.add(position);

            var geometry = new THREE.CylinderBufferGeometry(state.bRadius, state.bRadius, state.bLength, 16);
            var branch = new THREE.Mesh(geometry, material);
            branch.quaternion.copy(state.rotation);
            branch.position.copy(state.position);

            state.position.add(position);
            branch.castShadow = true;
            return branch;

        }

        function buildLeaf(state, material) {
            var transform = new THREE.Quaternion();
            transform.multiply(state.rotation);

            var originalPosition = new THREE.Vector3().copy(state.position);
            var position = new THREE.Vector3(0, state.bLength / 8, 0.0);
            position.applyQuaternion(state.rotation);
            state.position.add(position);

            var geometry = new THREE.SphereBufferGeometry(state.bLength / 4, 16);
            var branch = new THREE.Mesh(geometry, material);
            branch.quaternion.copy(state.rotation);
            branch.position.copy(state.position);

            state.position = new THREE.Vector3().copy(originalPosition);
            branch.castShadow = true;
            return branch;
        }

        function cloneState(state) {
            return {
                bRadius: state.bRadius,
                bLength: state.bLength,
                bReduction: state.bReduction,
                bMinRadius: state.bMinRadius,
                position: new THREE.Vector3().copy(state.position),
                rotation: new THREE.Quaternion().copy(state.rotation)
            }
        }


        function Params(axiom, iterations, delta, branchLength,
            branchRadius, branchReduction, branchMinRadius) {
            this.axiom = axiom ? axiom : "F";
            this.iterations = iterations ? iterations : 4;
            this.delta = delta ? delta : 25;
            this.branchLength = branchLength ? branchLength : 3;
            this.branchRadius = branchRadius ? branchRadius : 0.4;
            this.branchReduction = branchReduction ? branchReduction : 0.1;
            this.branchMinRadius = branchMinRadius ? branchMinRadius : 0.1;
        }


        function selectPreset() {
            var preset = $("#preset").val();
            if (preset == "Example A") {
                params = new Params("F", 5, 20, 4, 0.2);
                rules = "F=F[+F]F[-F][F]";
            }
            if (preset == "Example B") {
                params = new Params("F", 5, 25.7, 5, 1, 0.2, 0.2);
                rules = "F=F[+F]F[-F]F";
            }
            if (preset == "Example C") {
                params = new Params("F", 4, 22.5, 4, 0.1);
                rules = "F=FF-[-F+F+F]+[+F-F-F]";
            }
            if (preset == "Example D") {
                params = new Params("X", 7, 20);
                rules = "X=F[+X]F[-X]+X\nF=FF";
            }
            if (preset == "Example E") {
                params = new Params("X", 7, 25.7);
                rules = "X=F[+X][-X]FX\nF=FF";
            }
            if (preset == "Example F") {
                params = new Params("X", 5, 22.5);
                rules = "X=F-[[X]+X]+F[+FX]-X\nF=FF";
            }
            if (preset == "Example G") {
                params = new Params("FFFFFA", 4, 25);
                rules = "A=F[++A]X[--A]^^^A";
            }
            if (preset == "Example S") {
                params = new Params("F", 5, 25, 3, 0.3);
                rules = "F=F[+F]F[-F]F\nF=F[+F]F\nF=F[-F]F";
            }
        }

        function parseRules(rules) {
            var result = {};
            rules.split("\n").forEach(function (a) {
                var line = a.split("=");
                if (!result[line[0]]) {
                    result[line[0]] = [];
                }
                result[line[0]].push(line[1])
            });

            return result;
        }


        function Rewriter(rules) {
            this.rules = rules;

            this.rewrite = function (params) {
                var result = params.axiom;
                for (var i = 0; i < params.iterations; i++) {
                    var localResult = "";
                    for (var j = 0; j < result.length; j++) {
                        var char = result.charAt(j);
                        var rule = this.rules[char];
                        if (rule !== undefined) {
                            localResult += getRule(rule);
                        } else {
                            localResult += char;
                        }
                    }
                    result = localResult;
                }
                return result;
            };

        }

        function getRule(rules) {
            var probability = rules.length;
            var choice = probability > 1 ?
                parseInt((((Math.random() * probability) + 1) * 1000) / 1000) - 1 : 0;

            return rules[choice];
        }


        //let rules = "F=F[+F]F[-F]F\nF=F[+F]F\nF=F[-F]F";

        // old params: "F", 5, 25, 3, 0.3


        // let rules = parseRules("F=F[+F]F[-F]F\nF=F[+F]F\nF=F[-F]F");
        // let params = new Params("F", 5, 25, 4, 0.6);
        // var rewriter = new Rewriter(rules);
        // var string = rewriter.rewrite(params);
        // //console.log(string)
        // let newTree = new TreeBuilder(string, params).build();
        // let secondHalf = new TreeBuilder(string, params).build();

        // console.log(secondHalf.rotation);
        // secondHalf.rotation.y = 90;
        // scene.add(secondHalf);



        //let params = new Params("F", 5, 25, 3, 0.3);
        //let string = "F=F[+F]F[-F]F\nF=F[+F]F\nF=F[-F]F";
        //let newTree = new TreeBuilder(string, params).build();
        // scene.add(newTree);
        // console.log(newTree);




























        function rotateAboutWorldAxis(object, axis, angle) {
            var rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeRotationAxis(axis.normalize(), angle);
            var currentPos = new THREE.Vector4(object.position.x, object.position.y, object.position.z, 1);
            var newPos = currentPos.applyMatrix4(rotationMatrix);
            object.position.x = newPos.x;
            object.position.y = newPos.y;
            object.position.z = newPos.z;
        }

        function checkPositions(sun, moon) {
            let moonLight = moon.bulbLight;
            let sunLight = sun.bulbLight;
            let sunMaterial = sun.bulbMat;
            if (moonLight.position.y > 300) {
                renderer.setClearColor(skyColors[0]);
                cube.material.color.setHex(skyColors[0]);
                moonLight.intensity = .8;
            }
            else if (240 <= moonLight.position.y && moonLight.position.y < 300) {
                renderer.setClearColor(skyColors[1]);
                cube.material.color.setHex(skyColors[1]);
                moonLight.intensity = .7;
            }
            else if (180 <= moonLight.position.y && moonLight.position.y < 240) {
                moonLight.intensity = .6;
            }
            else if (120 <= moonLight.position.y && moonLight.position.y < 180) {
                renderer.setClearColor(skyColors[2]);
                cube.material.color.setHex(skyColors[2]);
                moonLight.intensity = .5;
            }
            else if (moonLight.position.y < 120 && moonLight.position.y > -.5) {
                moonLight.intensity = .4;
            }
            else if (moonLight.position.y < -.5) {
                moonLight.intensity = 0;
            }
            if (sunLight.position.y > 300) {
                //  console.log(sunLight.position.y, 'sun position AT highest');
                renderer.setClearColor(skyColors[5]);
                cube.material.color.setHex(skyColors[5]);
                sunLight.color.setHex(sunColors[0]);
                sunMaterial.emissive.set(sunColors[0]);
            }
            else if (240 <= sunLight.position.y && sunLight.position.y < 300) {
                //  console.log(sunLight.position.y, 'sun position AT MID');
                renderer.setClearColor(skyColors[4]);
                cube.material.color.setHex(skyColors[4]);
                sunLight.color.setHex(sunColors[1]);
                sunMaterial.emissive.set(sunColors[1]);
            }
            else if (180 <= sunLight.position.y && sunLight.position.y < 240) {
                //  console.log(sunLight.position.y, 'sun position AT second MID');
                sunLight.color.setHex(sunColors[2]);
                sunMaterial.emissive.set(sunColors[2]);
            }
            else if (120 <= sunLight.position.y && sunLight.position.y < 180) {
                // console.log(sunLight.position.y, 'sun position AT second to last lowest');
                renderer.setClearColor(skyColors[3]);
                cube.material.color.setHex(skyColors[3]);
                sunLight.color.setHex(sunColors[3]);
                sunMaterial.emissive.set(sunColors[3]);
            }
            else if (sunLight.position.y < 120 && sunLight.position.y > -.5) {
                //console.log(sunLight.position.y, 'LAST');
                sunLight.color.setHex(sunColors[4]);
                sunMaterial.emissive.set(sunColors[4]);
                sunLight.intensity = 1;
            }
            else if (sunLight.position.y < -.5) {
                //console.log(sunLight.position.y, 'turn sun off');
                sunLight.intensity = 0;
            }
        }

        //https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_collision_detection
        //The above link helped us with determining the equation we would use to calculate the distance between two
        //points
        //Calculates the distance between two points
        function calcDistance(point, shape) {
            //This calculates the distance of two points based on the distance formula
            const distance = Math.sqrt(
                (point.x - shape.position.x) * (point.x - shape.position.x) +
                (point.y - shape.position.y) * (point.y - shape.position.y) +
                (point.z - shape.position.z) * (point.z - shape.position.z)
            )
            return distance; //Returns distance
        }

        function randomizePositions() {

           
            let position = new THREE.Vector3(0, 0, 0);
            let rayHeight = new THREE.Raycaster();
            terrain.updateMatrixWorld()
            scene.updateMatrixWorld();
            rayHeight.layers.enableAll();
            var treePos = new THREE.Vector3();


            let xPos = Math.random() * 380;
            let yPos = 100;
            let zPos = Math.random() * 380;
            if (random() == true) {
                xPos *= -1;
                
            }
            if (random() == true) {
                zPos *= -1;
               
            }
            treePos.x = xPos;
            treePos.z = zPos;
            treePos.y = yPos;


            let rayDirection = new THREE.Vector3(0, -1, 0);
            rayHeight.ray.set(treePos, rayDirection.normalize());
          
            let intersectHeight = rayHeight.intersectObject(terrainShadow);

            

            // heightRay.set(rayPosition, rayDirection);
            //let intersectHeight = heightRay.intersectObject(terrain);

            //  let testgeometry = new THREE.SphereGeometry(25, 32, 32);
            // testgeometry.computeBoundingSphere(); //Compute a bounding sphere around each object
            // let testMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            // let mesh = new THREE.Mesh(testgeometry, testMaterial);
            // console.log(rayHeight);
            // mesh.position.set(rayHeight.ray.origin.x,rayHeight.ray.origin.y,rayHeight.ray.origin.z);
            // scene.add(mesh);

           


            if (intersectHeight.length != 0) {
                yPos = intersectHeight[0].point.y;
            }
           

            treePos.set(xPos, yPos, zPos);
            position.z = zPos;
            position.x = xPos;
            position.y = yPos;
            return position;

        }


        function makeTrees() {
            //axiom, iterations, delta, branchLength, branchRadius, branchReduction, branchMinRadius
            //let rules = parseRules("F=F[+F]F[-F]F\nF=F[+F]F\nF=F[-F]F");
            //let params = new Params("F", 4, 25, 4, 0.6);

             let params = new Params("F", 3, 22.5);


             //"F=F>[<+F]F[-F&]<F\nF=F&[+F^&^]F\nF=F[-F&]F&"

             //let rules = parseRules("F=F>[<+F]F[-F&]<F\nF=F&[+F^&^]F\nF=F[-F&]F&"); //1 set of rules

             //UGLY SAD TREE let rules = parseRules("F=F>[<+F]F[-F&&&^^FF]<F\nff&^^X\nF=F[AA-F&]F&");

             let rules = parseRules("F=F>[<+F]F[-F[]>&^^FF]<F\n\n<FX>");


             //let rules = parseRules("X=F-[[X]+X]+F[+FX]-X\nF=FF");
            //let params = new Params("A", 2, 22.5);
            //let rules = parseRules("A=F[++A]XF^^-[--A]^^^A");
            var rewriter = new Rewriter(rules);
            var string = rewriter.rewrite(params);


            // let testgeometry = new THREE.SphereGeometry(25, 32, 32);
            // testgeometry.computeBoundingSphere(); //Compute a bounding sphere around each object
            // let testMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            // let mesh = new THREE.Mesh(testgeometry, testMaterial);


            // newTree.children[0].computeBoundingSphere();
            //let secondHalf = new TreeBuilder(string, params).build();
            //secondHalf.rotation.y = 90;
            //scene.add(secondHalf);
            //worldItems.push(secondHalf);
            // trees.push(secondHalf);

            for (let i = 0; i < 20; i++) {
                let positionTree = randomizePositions();
                let newTree = new TreeBuilder(string, params).build();
                // console.log(newTree.children[0].geometry);
                // newTree.children[0].material.emissive.setHex(0xff0000);
                // for(let j = 0; j < newTree.children.length/2; j++){
                //     newTree.children[j].material.emissive.setHex(0xff0000);
                // }
                //console.log(newTree, 'new tree');
                newTree.position.set(positionTree.x, positionTree.y, positionTree.z);
                newTree.castShadow = true;
                newTree.receiveShadow = true;
                //trees.push(newTree); //ADDING NEW TREE TO TREES ARRAY CAUSES ERROR BECAUSE THERE IS NO BOUNDING SPHERE FOR THE TREE
                //AND BECAUSE YOU CANT SET THE EMISSIVE OF THE TREE FOR HIGHLIGHTING IN SUCH A WAY!!
                worldItems.push(newTree);
                trees.push(newTree);
                scene.add(newTree);
            }


        }

        makeTrees();
        console.log("final trees ", trees);
        //console.log(worldItems);
        //console.log(trees);
        // let test = new makeTrees(50, 10);
        // trees.push(test);
        // let test2 = new makeTrees(-50, 10);
        // trees.push(test2);
        // collision.push(test);
        // collision.push(test2);
        // collision.push(cube);

        //Function which detects whether the camera has collided with an object and then provides
        //some functionality to show that the collision was dealt with
        // function collisionDetection(point, shape) {
        //     let distance = calcDistance(point, shape); //Calculates the distance between the camera's position
        //     //and an object
        //     if (distance < shape.geometry.boundingSphere.radius) { //If the distance or camera is within the objects
        //         console.log("HELLER");
        //         return true;
        //     }
        //     else {
        //         return false;
        //     }
        // }
        let group = new THREE.Group();



        function makeBody() {

            let wholeBodyMaterial = new THREE.MeshPhongMaterial({
                //color: 0x000000,
                //transparent: true,
                // blending: THREE.AdditiveBlending,
                colorWrite: false,
                depthWrite: false

            });

            const headGeometry = new THREE.SphereGeometry(4, 32, 32);
            const headMaterial = wholeBodyMaterial;
            const head = new THREE.Mesh(headGeometry, wholeBodyMaterial);
            head.castShadow = true;
            head.receiveShadow = true;
            group.add(head);
            head.position.set(0, 2, 0);

            let bodyGeometry = new THREE.BoxGeometry(3, 8, 3)
            const bodyMaterial = wholeBodyMaterial;
            let body = new THREE.Mesh(bodyGeometry, wholeBodyMaterial)
            body.castShadow = true;
            body.receiveShadow = true;
            body.position.set(0, -4, 0);
            group.add(body)


            let leftArmGeometry = new THREE.BoxGeometry(1.2, 10, 1.2)
            const leftArmMaterial = wholeBodyMaterial;
            let leftArm = new THREE.Mesh(leftArmGeometry, wholeBodyMaterial)
            leftArm.castShadow = true;
            leftArm.receiveShadow = true;
            leftArm.rotateZ(-Math.PI / 3);
            leftArm.position.set(-3.3, -3.5, 0);
            group.add(leftArm);

            let rightArmGeometry = new THREE.BoxGeometry(1.2, 10, 1.2)
            const rightArmMaterial = wholeBodyMaterial;
            let rightArm = new THREE.Mesh(rightArmGeometry, wholeBodyMaterial)
            rightArm.castShadow = true;
            rightArm.receiveShadow = true;
            rightArm.rotateZ(Math.PI / 3);


            rightArm.position.set(3.3, -3.5, 0);
            group.add(rightArm);


            let rightLegGeometry = new THREE.BoxGeometry(2, 10, 2)
            const rightLegMaterial = wholeBodyMaterial;
            let rightLeg = new THREE.Mesh(rightLegGeometry, wholeBodyMaterial)
            rightLeg.castShadow = true;
            rightLeg.receiveShadow = true;
            rightLeg.rotateZ(Math.PI / 6);
            rightLeg.position.set(3.3, -12, 0);
            group.add(rightLeg);

            let leftLegGeometry = new THREE.BoxGeometry(2, 10, 2)
            const leftLegMaterial = wholeBodyMaterial;
            let leftLeg = new THREE.Mesh(leftLegGeometry, wholeBodyMaterial)
            leftLeg.castShadow = true;
            leftLeg.receiveShadow = true;
            leftLeg.rotateZ(-Math.PI / 6);


            leftLeg.position.set(-3.3, -12, 0);
            group.add(leftLeg);
            //console.log(group.children[0].lookAt, 'GROUP LOOK AT');
        }

        makeBody();

        scene.add(group);

        function animate() {
            change += .2;
            sinwave = Math.sin(change);


            let ray = new THREE.Raycaster();
            var rayPos = new THREE.Vector3();

            rayPos.set(camera.position.x, camera.position.y, camera.position.z);
            var rayDir = new THREE.Vector3(0, -1, 0);
            ray.set(rayPos, rayDir);
            let intersect = ray.intersectObject(terrain);

            if (intersect.length != 0) {
                if (moving == true) {
                    displacement = sinwave * .1;
                    camera.position.y = (intersect[0].point.y + 20) + displacement * camera.position.y;
                }
                else {
                    camera.position.y = (intersect[0].point.y + 20)
                }
            }
            else {
                camera.position.y = 50;
            }

            requestAnimationFrame(animate);
            const time = performance.now();
            if (controls.isLocked === true) {
                // for (let i = 0; i < trees.length; i++) {
                //     //if (collisionDetection(cursor.position, trees[i]) == true) {
                //     //   newTree.children[0].material.emissive.setHex(0xff0000);
                //     // }
                //     // else {
                //     //    trees[i].material.emissive.setHex(0x000000);
                //     // }
                // }
                const delta = (time - prevTime) / 1000;

                let yPos = camera.position.y - 5;
                group.position.y = (yPos);
                group.position.z = (camera.position.z);
                group.position.x = (camera.position.x);

                group.setRotationFromMatrix(camera.matrix);


            }


            prevTime = time;
            renderer.render(scene, camera);
        }


        function render() {
            for (let m = 0; m < trees.length; m++) {
                //  console.log(trees[m], " BITCH");
                trees[m].children[0].material.emissive.setHex(0x000000);
            }

            raycaster.set(camera.getWorldPosition(new THREE.Vector3), camera.getWorldDirection(new THREE.Vector3));
            const intersections = raycaster.intersectObjects(worldItems, true);
            const lightTrees = raycaster.intersectObjects(trees, true);
            intersection = (intersections.length) > 0 ? intersections[0] : null;
            if (toggle > 0.001 && intersection !== null) {
                spheres[spheresIndex].position.copy(intersection.point);
                toggle = 0;
            }

            //console.log(lightTrees);
            if (lightTrees.length > 0) {
                lightTrees[0].object.material.emissive.set(0xff0000);
            }
            // if (intersections.length > 0){
            //     intersections[0].object.material.emissive.setHex(0xff0000);

            // }
            // for (let i = 0; i < intersections.length; i++) {
            //     //intersections[i].object.material.setValues({emissive: 0xff0000});
            //     intersections[i].object.material.color.emissive = 0xff0000;
            //    // intersections[i].object.material.color.set(0x000000);
            // }

            let distance = calcDistance(camera.position, cursor);
            if (distance != null) {
                cursor.scale.set(distance * .5, distance * .5, distance * .5);
            }
            toggle += clock.getDelta();
            updateSize();
            requestAnimationFrame(render);
            const time = performance.now();
            const delta = time - previousTime;
            // We need to translate the object back to the origin before rotating it:
            rotateAboutWorldAxis(sun.bulbLight, new THREE.Vector3(0.0, 0.0, 1.0), turnSpeed * .005);
            rotateAboutWorldAxis(moon.bulbLight, new THREE.Vector3(0.0, 0.0, 1.0), turnSpeed * .005);
            checkPositions(sun, moon);
            previousTime = time;
            renderer.render(scene, camera);
        }
        //source: https://threejs.org/examples/webgl_multiple_views.html
        //This function updates the window width and height variables to the actual width and height of the computer
        //regardless of whether the console has been opened or not
        function updateSize() {
            if (windowWidth != window.innerWidth || windowHeight != window.innerHeight) { //If the window width or height has
                //actually been changed than this if statement is triggered
                windowWidth = window.innerWidth;
                windowHeight = window.innerHeight;
                renderer.setSize(windowWidth, windowHeight);
            }
        }
        let collisionRayCaster = new THREE.Raycaster();

        var movement;
        function onDocumentKeyDown(e) {

            movement = 0;
            var keyCode = e.which || e.keyCode;
            if (keyCode == 87) movement = "forward";
            else if (keyCode == 65) movement = "left";
            else if (keyCode == 68) movement = "right";
            else if (keyCode == 83) movement = "backward";
            if (movement != 0) moveAround();
        }

        var oldCamera;
        let speed = 2;

        function moveAround() {
            moving = true;
            oldCamera = camera.clone();
            if (movement == "forward") camera.translateZ(-speed);
            if (movement == "left") camera.translateX(-speed);
            if (movement == "backward") camera.translateZ(speed);
            if (movement == "right") camera.translateX(speed);
            collisionRayCaster.set(camera.position, oldCamera.position.normalize());

            if (collisionRayCaster.intersectObjects(trees).length > 0) {
                console.log("does it get in");

                if (movement == "forward") camera.translateZ(speed);
                if (movement == "left") camera.translateX(speed);
                if (movement == "backward") camera.translateZ(-speed);
                if (movement == "right") camera.translateX(-speed);
            }
            else if (camera.position.x < -380 || camera.position.x > 380 || camera.position.z < -380 || camera.position.z > 380) {
                if (movement == "forward") camera.translateZ(speed);
                if (movement == "left") camera.translateX(speed);
                if (movement == "backward") camera.translateZ(-speed);
                if (movement == "right") camera.translateX(-speed);
            }
        };
        document.addEventListener('keydown', onDocumentKeyDown, false);

        document.addEventListener('keyup', (event) => {
            moving = false;
        });

        animate();
        render();
    </script>
</body>

</html>