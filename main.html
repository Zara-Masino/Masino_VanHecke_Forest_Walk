<html>

<head>
    <title>Walk in Forest</title>
</head>

<body>

    <canvas id="myCanvas" width="800" height="800"></canvas>

    <script type="module">
        import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
        import { PointerLockControls } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/controls/PointerLockControls.js';


        var scene = new THREE.Scene();
        let raycaster = new THREE.Raycaster();

        const pointer = new THREE.Vector2();
        const spheres = [];
        let worldItems = [];

        let intersection = null;
        let toggle = 0;
        let clock = new THREE.Clock();

        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;

        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();


        const sphereGeometry = new THREE.SphereGeometry(0.02, 16, 16);
        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });

        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        scene.add(sphere);
        spheres.push(sphere);


        var world = new THREE.BoxGeometry(20, 20, 20);
        var wmat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: false });

        /* Cause the material to be visible for inside and outside */
        wmat.side = THREE.BackSide;

        var cube = new THREE.Mesh(world, wmat);
        scene.add(cube);
        worldItems.push(cube);




        const geometry = new THREE.PlaneGeometry(10, 10);
        const material = new THREE.MeshPhongMaterial({ color: 0x90EE90, side: THREE.DoubleSide });
        const plane = new THREE.Mesh(geometry, material);
        plane.position.set(0.0, -0.5, 0.0);
        plane.rotation.x = Math.PI / 2;
        scene.add(plane);
        worldItems.push(plane);
        let turnSpeed = .1;


        let sunColors = [0xf7e2ba, 0xffdaa8, 0xf8cb7c, 0xfdb25b, 0xfa9e4d];
        let moonColor = [0xdde2e5];
        let skyColors = [0x000608, 0x072f41, 0x094f6d, 0x436e91, 0x5e88b8, 0x7998bb];

        let windowWidth = window.innerWidth;
        let windowHeight = window.innerHeight;


        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.lookAt(new THREE.Vector3(0.0, 0.0, 0.0));
        camera.position.set(0, 2, 10);
        scene.add(camera);
        let previousTime = performance.now();

        var renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
        renderer.setClearColor(0xADD8E6);
        // If you want this to span the window, instead of using the myCanvas object, use the window object
        renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);
        // If you want the render to span the window, uncomment this
        renderer.setSize(window.innerWidth, window.innerHeight);
        //renderer.shadowMap.enable = true;



        //source: https://threejs.org/examples/webgl_multiple_views.html
        //This function updates the window width and height variables to the actual width and height of the computer
        //regardless of whether the console has been opened or not
        function updateSize() {
            if (windowWidth != window.innerWidth || windowHeight != window.innerHeight) { //If the window width or height has
                //actually been changed than this if statement is triggered
                windowWidth = window.innerWidth;
                windowHeight = window.innerHeight;
                renderer.setSize(windowWidth, windowHeight);
            }
        }


        var controls = new PointerLockControls(camera, document.body);

        document.addEventListener('click', function () {
            controls.lock();
        });

        document.addEventListener('mousemove', onPointerMove);


        function onPointerMove(event) {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }


        function makeLights(hexCode, x, y, z, intensity) {
            //Creates a sphere and pointlight and adds them both to the scene
            renderer.setClearColor(0x000608);
            this.bulbGeometry = new THREE.SphereGeometry(0.4, 32, 16);
            this.bulbLight = new THREE.PointLight(hexCode, intensity, 100); //Creates point light
            //color of the light being directed
            this.bulbMat = new THREE.MeshStandardMaterial({ //Creates bulb material for the light
                emissive: hexCode, //color of the bulb
                emissiveIntensity: 1,
                color: 0xffff00
            });
            this.bulbLight.add(new THREE.Mesh(this.bulbGeometry, this.bulbMat)); //Adds bulb geometry and bulb light to the point light
            this.bulbLight.position.set(x, y, z); //Positions the bulblight 
            this.bulbLight.castShadow = true; //Casts shadow from the bulb light
            scene.add(this.bulbLight); //Adds bulb light to the scene
        }


        let moon = new makeLights(moonColor[0], -4, -5, 0, .1);
        let sun = new makeLights(sunColors[4], 4, 5, 0, 1);
        worldItems.push(sun.bulbLight);
        worldItems.push(moon.bulbLight);



        function rotateAboutWorldAxis(object, axis, angle) {
            var rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeRotationAxis(axis.normalize(), angle);
            var currentPos = new THREE.Vector4(object.position.x, object.position.y, object.position.z, 1);
            var newPos = currentPos.applyMatrix4(rotationMatrix);
            object.position.x = newPos.x;
            object.position.y = newPos.y;
            object.position.z = newPos.z;
        }


        function checkPositions(sun, moon) {
            let moonLight = moon.bulbLight;
            let sunLight = sun.bulbLight;
            let sunMaterial = sun.bulbMat;
            if (moonLight.position.y > 4) {
                renderer.setClearColor(skyColors[0]);
                cube.material.color.setHex(skyColors[0]);
                moonLight.intensity = .8;
            }
            else if (3 <= moonLight.position.y && moonLight.position.y < 4) {
                renderer.setClearColor(skyColors[1]);
                cube.material.color.setHex(skyColors[1]);
                moonLight.intensity = .7;
            }
            else if (2 <= moonLight.position.y && moonLight.position.y < 3) {
                moonLight.intensity = .6;
            }
            else if (1 <= moonLight.position.y && moonLight.position.y < 2) {
                renderer.setClearColor(skyColors[2]);
                cube.material.color.setHex(skyColors[2]);
                moonLight.intensity = .5;
            }
            else if (moonLight.position.y < 1) {
                moonLight.intensity = .4;
            }

            if (sunLight.position.y > 4) {
                renderer.setClearColor(skyColors[5]);
                cube.material.color.setHex(skyColors[5]);
                sunLight.color.setHex(sunColors[0]);
                sunMaterial.emissive.set(sunColors[0]);
            }
            else if (3 <= sunLight.position.y && sunLight.position.y < 4) {
                renderer.setClearColor(skyColors[4]);
                cube.material.color.setHex(skyColors[4]);
                sunLight.color.setHex(sunColors[1]);
                sunMaterial.emissive.set(sunColors[1]);
            }
            else if (2 <= sunLight.position.y && sunLight.position.y < 3) {
                sunLight.color.setHex(sunColors[2]);
                sunMaterial.emissive.set(sunColors[2]);
            }
            else if (1 <= sunLight.position.y && sunLight.position.y < 2) {
                renderer.setClearColor(skyColors[3]);
                cube.material.color.setHex(skyColors[3]);
                sunLight.color.setHex(sunColors[3]);
                sunMaterial.emissive.set(sunColors[3]);
            }
            else if (sunLight.position.y < 1) {
                sunLight.color.setHex(sunColors[4]);
                sunMaterial.emissive.set(sunColors[4]);
            }

        }

        //https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_collision_detection
        //The above link helped us with determining the equation we would use to calculate the distance between two
        //points
        //Calculates the distance between two points
        function calcDistance(point, shape) {
            //This calculates the distance of two points based on the distance formula
            const distance = Math.sqrt(
                (point.x - shape.position.x) * (point.x - shape.position.x) +
                (point.y - shape.position.y) * (point.y - shape.position.y) +
                (point.z - shape.position.z) * (point.z - shape.position.z)
            )
            return distance; //Returns distance
        }


        function animate() {

            requestAnimationFrame(animate);

            const time = performance.now();

            if (controls.isLocked === true) {

                const delta = (time - prevTime) / 1000;

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize(); // this ensures consistent movements in all directions

                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;


                controls.moveRight(- velocity.x * delta);
                controls.moveForward(- velocity.z * delta);

                controls.getObject().position.y += (velocity.y * delta); // new behavior

                if (controls.getObject().position.y < 0) {

                    velocity.y = 0;
                    controls.getObject().position.y = 0;

                    canJump = true;

                }

            }

            prevTime = time;

            renderer.render(scene, camera);

        }



        function render() {

            raycaster.set(camera.getWorldPosition(new THREE.Vector3), camera.getWorldDirection(new THREE.Vector3));
            //console.log('distance', calcDistance(camera.position, sphere));
            let distance = calcDistance(camera.position, sphere);

            sphere.scale.set(distance * .5, distance * .5, distance * .5);


            const intersections = raycaster.intersectObjects(worldItems, false);
            intersection = (intersections.length) > 0 ? intersections[0] : null;

            if (toggle > 0.001 && intersection !== null) {

                spheres[0].position.copy(intersection.point);
                toggle = 0;

            }


            toggle += clock.getDelta();

            updateSize();
            requestAnimationFrame(render);

            const time = performance.now();
            const delta = time - previousTime;

            // We need to translate the object back to the origin before rotating it:
            rotateAboutWorldAxis(sun.bulbLight, new THREE.Vector3(0.0, 0.0, 1.0), turnSpeed * .05);
            rotateAboutWorldAxis(moon.bulbLight, new THREE.Vector3(0.0, 0.0, 1.0), turnSpeed * .05);
            checkPositions(sun, moon);


            previousTime = time;
            renderer.render(scene, camera);
        }



        const onKeyDown = function (event) {

            switch (event.code) {

                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;

                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;

                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;

                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;

                case 'Space':
                    if (canJump === true) velocity.y += 350;
                    canJump = false;
                    break;

            }

        };

        const onKeyUp = function (event) {

            switch (event.code) {

                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;

                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;

                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;

                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;

            }

        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);




        animate();
        render();
    </script>
</body>

</html>