<html>

<head>
    <title>Three.js Geometries Example</title>
</head>

<body>

    <canvas id="myCanvas" width="800" height="800"></canvas>

    <script type="module">
        import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
        import { PointerLockControls } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/controls/PointerLockControls.js';


        var scene = new THREE.Scene();
        let raycaster = new THREE.Raycaster();
        let trees = [];

        const pointer = new THREE.Vector2();
        let INTERSECTED;
        const spheres = [];
        const spheresIndex = 0;
        let worldItems = [];

        let intersection = null;
        let toggle = 0;
        let clock = new THREE.Clock();

        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;

        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const vertex = new THREE.Vector3();
        const color = new THREE.Color();

        let directionn = new THREE.Vector3();
        let backDirection = new THREE.Vector3();

        let sunColors = [0xf7e2ba, 0xffdaa8, 0xf8cb7c, 0xfdb25b, 0xfa9e4d];
        let moonColor = [0xdde2e5];
        let skyColors = [0x000608, 0x072f41, 0x094f6d, 0x436e91, 0x5e88b8, 0x7998bb];

        let windowWidth = window.innerWidth;
        let windowHeight = window.innerHeight;

        const loader = new THREE.TextureLoader();


        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.lookAt(new THREE.Vector3(0.0, 0.0, 0.0));
        camera.position.set(0, 80, 10);
        scene.add(camera);
        let previousTime = performance.now();

        var renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
        renderer.setClearColor(0xADD8E6);
        // If you want this to span the window, instead of using the myCanvas object, use the window object
        renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);
        // If you want the render to span the window, uncomment this
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        //        renderer.shadowMap.type = THREE.BasicShadowMap;

        renderer.shadowMapSoft = true;
        renderer.shadowMapType = THREE.PCFSoftShadowMap;



        var controls = new PointerLockControls(camera, document.body);

        document.addEventListener('click', function () {
            controls.lock();
        });



        document.addEventListener('mousemove', onPointerMove);


        function onPointerMove(event) {

            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

        }



        const sphereGeometry = new THREE.SphereGeometry(0.02, 16, 16);
        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });

        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        scene.add(sphere);
        spheres.push(sphere);



        var world = new THREE.BoxGeometry(900, 900, 900);
        var wmat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: false });

        /* Cause the material to be visible for inside and outside */
        wmat.side = THREE.BackSide;

        var cube = new THREE.Mesh(world, wmat);
        scene.add(cube);
        worldItems.push(cube);



        function makeLights(hexCode, x, y, z, intensity) {
            //Creates a sphere and pointlight and adds them both to the scene
            renderer.setClearColor(0x000608);
            this.bulbGeometry = new THREE.SphereGeometry(10, 32, 16);
            this.bulbLight = new THREE.PointLight(hexCode, intensity, 20000); //Creates point light
            //color of the light being directed
            this.bulbMat = new THREE.MeshPhongMaterial({ //Creates bulb material for the light
                emissive: hexCode, //color of the bulb
                emissiveIntensity: 1,
                color: 0xffff00
            });
            this.bulbLight.add(new THREE.Mesh(this.bulbGeometry, this.bulbMat)); //Adds bulb geometry and bulb light to the point light
            this.bulbLight.position.set(x, y, z); //Positions the bulblight 
            this.bulbLight.castShadow = true; //Casts shadow from the bulb light
            this.bulbLight.shadow.bias = - 0.0005; // reduces self-shadowing on double-sided objects
            //  this.bulbLight.shadow.bias = - 0.0005; // reduces self-shadowing on double-sided objects
            this.bulbLight.shadow.radius = 8;
            this.bulbLight.shadow.mapSize.width = 2048; // You have there 4K no need to go over 2K

            this.bulbLight.shadow.mapSize.height = 2048; // 



            // this.bulbLight.shadow.mapSize.width = 2048;
            // this.bulbLight.shadow.mapSize.height = 2048;
            scene.add(this.bulbLight); //Adds bulb light to the scene
        }

        // makeLights(0xacdef3, 0);

        //makeLights(skyColors[4], 4);
        let moon = new makeLights(moonColor[0], -255, -255, 0, .1);
        let sun = new makeLights(sunColors[4], 255, 255, 0, 1);
        worldItems.push(sun.bulbLight);
        worldItems.push(moon.bulbLight);






        class Perlin {
            constructor() {
                this.grad3 =
                    [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
                    [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
                    [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]];
                this.p = [];
                for (var i = 0; i < 256; i++) {
                    this.p[i] = Math.floor(Math.random() * 256);
                }

                // To remove the need for index wrapping, double the permutation table length 
                this.perm = [];
                for (i = 0; i < 512; i++) {
                    this.perm[i] = this.p[i & 255];
                }

                // A lookup table to traverse the simplex around a given point in 4D. 
                // Details can be found where this table is used, in the 4D noise method. 
                this.simplex = [
                    [0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0],
                    [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0],
                    [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],
                    [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0],
                    [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0],
                    [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],
                    [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0],
                    [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]];
            }

            dot(g, x, y) {
                return g[0] * x + g[1] * y;
            }

            noise(xin, yin) {
                var n0, n1, n2; // Noise contributions from the three corners 
                // Skew the input space to determine which simplex cell we're in 
                var F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
                var s = (xin + yin) * F2; // Hairy factor for 2D 
                var i = Math.floor(xin + s);
                var j = Math.floor(yin + s);
                var G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
                var t = (i + j) * G2;
                var X0 = i - t; // Unskew the cell origin back to (x,y) space 
                var Y0 = j - t;
                var x0 = xin - X0; // The x,y distances from the cell origin 
                var y0 = yin - Y0;
                // For the 2D case, the simplex shape is an equilateral triangle. 
                // Determine which simplex we are in. 
                var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords 
                if (x0 > y0) { i1 = 1; j1 = 0; } // lower triangle, XY order: (0,0)->(1,0)->(1,1) 
                else { i1 = 0; j1 = 1; }      // upper triangle, YX order: (0,0)->(0,1)->(1,1) 
                // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and 
                // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where 
                // c = (3-sqrt(3))/6 
                var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords 
                var y1 = y0 - j1 + G2;
                var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords 
                var y2 = y0 - 1.0 + 2.0 * G2;
                // Work out the hashed gradient indices of the three simplex corners 
                var ii = i & 255;
                var jj = j & 255;
                var gi0 = this.perm[ii + this.perm[jj]] % 12;
                var gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
                var gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
                // Calculate the contribution from the three corners 
                var t0 = 0.5 - x0 * x0 - y0 * y0;
                if (t0 < 0) n0 = 0.0;
                else {
                    t0 *= t0;
                    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);  // (x,y) of grad3 used for 2D gradient 
                }
                var t1 = 0.5 - x1 * x1 - y1 * y1;
                if (t1 < 0) n1 = 0.0;
                else {
                    t1 *= t1;
                    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
                }
                var t2 = 0.5 - x2 * x2 - y2 * y2;
                if (t2 < 0) n2 = 0.0;
                else {
                    t2 *= t2;
                    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
                }
                // Add contributions from each corner to get the final noise value. 
                // The result is scaled to return values in the interval [-1,1]. 
                return 70.0 * (n0 + n1 + n2);
            }
        }





        var geometry1 = new THREE.PlaneBufferGeometry(800, 800, 256, 256);
        var material1 = new THREE.MeshPhysicalMaterial({ map: loader.load('land/water3.jpg') });
        var water = new THREE.Mesh(geometry1, material1);
        water.rotation.x = -Math.PI / 2;
        water.position.y =-25;
        //water.receiveShadow = true;
        scene.add(water);
        console.log(water);


        var geometry = new THREE.PlaneBufferGeometry(800, 800, 256, 256);
        var material = new THREE.MeshPhysicalMaterial({ map: loader.load('land/sand3.jpg') });
        var plane = new THREE.Mesh(geometry, material);
        plane.rotation.x = -Math.PI / 2;
        scene.add(plane);
        console.log(plane);

        var peak = 60;
        var vertices = plane.geometry.attributes.position.array;
        for (var i = 0; i <= vertices.length; i += 3) {
            vertices[i + 2] = peak * Math.random();
        }
        plane.geometry.attributes.position.needsUpdate = true;
        plane.geometry.computeVertexNormals();



        //makes shadows not completely opaque. but the plane itself does not receive/cast shadow
        let planeMaterial = new THREE.ShadowMaterial();
        planeMaterial.opacity = 0.5;
        var shadowPlane = new THREE.Mesh(geometry, planeMaterial);
        shadowPlane.receiveShadow = true;
        shadowPlane.position.copy(plane.position);
        shadowPlane.rotation.copy(plane.rotation);
        scene.add(shadowPlane);


        //makes shadows not completely opaque. but the plane itself does not receive/cast shadow
        let waterMaterial = new THREE.ShadowMaterial();
        waterMaterial.opacity = 0.5;
        var waterShadow = new THREE.Mesh(geometry1, waterMaterial);
        waterShadow.receiveShadow = true;
        waterShadow.position.copy(water.position);
        waterShadow.rotation.copy(water.rotation);
        scene.add(waterShadow);

        console.log(waterShadow, 'WATER');




        var perlin = new Perlin();
        var peak = 60;
        var smoothing = 300;
        var vertices = plane.geometry.attributes.position.array;
        for (var i = 0; i <= vertices.length; i += 3) {
            vertices[i + 2] = peak * perlin.noise(
                vertices[i] / smoothing,
                vertices[i + 1] / smoothing
            );
        }
        plane.geometry.attributes.position.needsUpdate = true;
        plane.geometry.computeVertexNormals();









        // const geometry = new THREE.PlaneGeometry(10, 10);
        // const material = new THREE.MeshPhongMaterial({ color: 0x90EE90, side: THREE.DoubleSide });
        // const plane = new THREE.Mesh(geometry, material);
        // plane.position.set(0.0, -0.5, 0.0);

        // plane.rotation.x -= Math.PI / 2;
        // scene.add(plane);
        plane.castShadow = true;
       // plane.receiveShadow = true;
        worldItems.push(plane);
        let turnSpeed = .1;

        function rotateAboutWorldAxis(object, axis, angle) {
            var rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeRotationAxis(axis.normalize(), angle);
            var currentPos = new THREE.Vector4(object.position.x, object.position.y, object.position.z, 1);
            var newPos = currentPos.applyMatrix4(rotationMatrix);
            object.position.x = newPos.x;
            object.position.y = newPos.y;
            object.position.z = newPos.z;
        }


        function checkPositions(sun, moon) {
            let moonLight = moon.bulbLight;
            let sunLight = sun.bulbLight;

            let sunMaterial = sun.bulbMat;
            if (moonLight.position.y > 300) {
                renderer.setClearColor(skyColors[0]);
                cube.material.color.setHex(skyColors[0]);
                moonLight.intensity = .8;
            }
            else if (240 <= moonLight.position.y && moonLight.position.y < 300) {
                renderer.setClearColor(skyColors[1]);
                cube.material.color.setHex(skyColors[1]);
                moonLight.intensity = .7;
            }
            else if (180 <= moonLight.position.y && moonLight.position.y < 240) {
                moonLight.intensity = .6;
            }
            else if (120 <= moonLight.position.y && moonLight.position.y < 180) {
                renderer.setClearColor(skyColors[2]);
                cube.material.color.setHex(skyColors[2]);
                moonLight.intensity = .5;
            }
            else if (moonLight.position.y < 120 && moonLight.position.y > -.5) {
                moonLight.intensity = .4;
            }
            else if (moonLight.position.y < -.5) {
                moonLight.intensity = 0;
            }

            if (sunLight.position.y > 300) {
                //  console.log(sunLight.position.y, 'sun position AT highest');

                renderer.setClearColor(skyColors[5]);
                cube.material.color.setHex(skyColors[5]);
                sunLight.color.setHex(sunColors[0]);
                sunMaterial.emissive.set(sunColors[0]);
            }
            else if (240 <= sunLight.position.y && sunLight.position.y < 300) {
                //  console.log(sunLight.position.y, 'sun position AT MID');
                renderer.setClearColor(skyColors[4]);
                cube.material.color.setHex(skyColors[4]);
                sunLight.color.setHex(sunColors[1]);
                sunMaterial.emissive.set(sunColors[1]);
            }
            else if (180 <= sunLight.position.y && sunLight.position.y < 240) {
                //  console.log(sunLight.position.y, 'sun position AT second MID');
                sunLight.color.setHex(sunColors[2]);
                sunMaterial.emissive.set(sunColors[2]);
            }
            else if (120 <= sunLight.position.y && sunLight.position.y < 180) {
                // console.log(sunLight.position.y, 'sun position AT second to last lowest');
                renderer.setClearColor(skyColors[3]);
                cube.material.color.setHex(skyColors[3]);
                sunLight.color.setHex(sunColors[3]);
                sunMaterial.emissive.set(sunColors[3]);
            }
            else if (sunLight.position.y < 120 && sunLight.position.y > -.5) {
                //console.log(sunLight.position.y, 'LAST');
                sunLight.color.setHex(sunColors[4]);
                sunMaterial.emissive.set(sunColors[4]);
                sunLight.intensity = 1;
            }
            else if (sunLight.position.y < -.5) {
                //console.log(sunLight.position.y, 'turn sun off');
                sunLight.intensity = 0;
            }


        }

        //https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_collision_detection
        //The above link helped us with determining the equation we would use to calculate the distance between two
        //points
        //Calculates the distance between two points
        function calcDistance(point, shape) {
            //This calculates the distance of two points based on the distance formula
            const distance = Math.sqrt(
                (point.x - shape.position.x) * (point.x - shape.position.x) +
                (point.y - shape.position.y) * (point.y - shape.position.y) +
                (point.z - shape.position.z) * (point.z - shape.position.z)
            )
            return distance; //Returns distance
        }
        //point 2 is lookat
        //point is camera
        function calcBehind(point, point2) {
            //This calculates the distance of two points based on the distance formula
            // console.log(point, 'POINT1 CHECK');
            // console.log(point2, 'POINT2 CHECK');
            const distance = Math.sqrt(
                (point.x - point2.x) * (point.x - point2.x) +
                (point.y - point2.y) * (point.y - point2.y) +
                (point.z - point2.z) * (point.z - point2.z)
            )

            console.log(distance, 'DISTANCE CHECK');


            point2.x = distance * .05;
            point2.y = distance * .05;
            point2.z = distance * .05;

            return point2; //Returns distance
        }

        function makeTrees(x, y) {
            let testgeometry = new THREE.SphereGeometry(.5, 32, 32);
            testgeometry.computeBoundingSphere(); //Compute a bounding sphere around each object
            let testMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            let mesh = new THREE.Mesh(testgeometry, testMaterial);
            mesh.position.set(x, y, 0);
            worldItems.push(mesh);
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            scene.add(mesh);
            return mesh;

        }
        let x = .1;
        let y = .1;
        // for (let i = 0; i < 3; i++) {
        //     let tree1 = new makeTrees(x, y);
        //     x += 1;
        //     y += 1;
        //     trees.push(tree1);
        // }

        //,console.log(trees);



        //Function which detects whether the camera has collided with an object and then provides
        //some functionality to show that the collision was dealt with
        function collisionDetection(point, shape) {
            let distance = calcDistance(point, shape); //Calculates the distance between the camera's position
            //and an object
            if (distance < shape.geometry.boundingSphere.radius) { //If the distance or camera is within the objects
                console.log("HELLER");
                return true;
            }
            else {
                return false;
            }
        }

        let group = new THREE.Group();

        function makeBody() {
            const headGeometry = new THREE.SphereGeometry(10, 32, 32);
            const headMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.castShadow = true;
            head.receiveShadow = true;
            group.add(head);
            head.position.set(1, 1.65, 1);

            let bodyGeometry = new THREE.BoxGeometry(0.35, 1, 0.35)
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            let body = new THREE.Mesh(bodyGeometry, bodyMaterial)
            body.castShadow = true;
            body.receiveShadow = true;
            body.position.set(1, 1, 1);
            group.add(body)


            let leftArmGeometry = new THREE.BoxGeometry(0.15, .75, 0.15)
            const leftArmMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            let leftArm = new THREE.Mesh(leftArmGeometry, leftArmMaterial)
            leftArm.castShadow = true;
            leftArm.receiveShadow = true;
            leftArm.rotateZ(-Math.PI / 3);
            leftArm.position.set(.60, .9, 1);
            group.add(leftArm);

            let rightArmGeometry = new THREE.BoxGeometry(0.15, .75, 0.15)
            const rightArmMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            let rightArm = new THREE.Mesh(rightArmGeometry, rightArmMaterial)
            rightArm.castShadow = true;
            rightArm.receiveShadow = true;
            rightArm.rotateZ(Math.PI / 3);
            rightArm.position.set(1.4, .9, 1);
            group.add(rightArm);


            let rightLegGeometry = new THREE.BoxGeometry(0.25, 1.25, 0.25)
            const rightLegMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            let rightLeg = new THREE.Mesh(rightLegGeometry, rightLegMaterial)
            rightLeg.castShadow = true;
            rightLeg.receiveShadow = true;
            rightLeg.rotateZ(Math.PI / 6);
            rightLeg.position.set(1.4, 0, 1);
            group.add(rightLeg);

            let leftLegGeometry = new THREE.BoxGeometry(0.25, 1.25, 0.25)
            const leftLegMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            let leftLeg = new THREE.Mesh(leftLegGeometry, leftLegMaterial)
            leftLeg.castShadow = true;
            leftLeg.receiveShadow = true;
            leftLeg.rotateZ(-Math.PI / 6);
            leftLeg.position.set(.60, 0, 1);
            group.add(leftLeg);
            console.log(group.children[0].lookAt, 'GROUP LOOK AT');
        }

        // console.log('group', group.children[0]);

        makeBody();

        group.add(camera);

        scene.add(group);

        // console.log('head', group);

        function rearCamera(directionn) {
            //Gets the look at for the rear view look at by doing the following:
            //1. Multiplies the look at of the forward looking camera by -1
            //2. Adds the look at to the camera's position
            //3. This new value is the look at for the rear view camera
            backDirection.x = (directionn.x * -1) + camera.position.x;
            backDirection.y = (directionn.y * -1) + camera.position.y;
            backDirection.z = (directionn.z * -1) + camera.position.z;
            // console.log(backDirection, 'backdirection');
        }


        function animate() {

            camera.getWorldDirection(directionn)

            rearCamera(directionn);






            requestAnimationFrame(animate);

            const time = performance.now();

            if (controls.isLocked === true) {


                for (let i = 0; i < trees.length; i++) {
                    if (collisionDetection(sphere.position, trees[i]) == true) {
                        trees[i].material.emissive.setHex(0xff0000);
                    }
                    else {
                        trees[i].material.emissive.setHex(0x000000);
                    }
                }

                // raycaster.ray.origin.copy(controls.getObject().position);
                //raycaster.ray.origin.y -= 10;

                // const intersections = raycaster.intersectObjects(objects, false);

                // const onObject = intersections.length > 0;

                const delta = (time - prevTime) / 1000;

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize(); // this ensures consistent movements in all directions

                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;


                controls.moveRight(- velocity.x * delta);
                controls.moveForward(- velocity.z * delta);

                // console.log(backDirection, 'BACK DIRECTION ');
                // console.log(camera.position, 'CAMERA.POSITION');

                //let newPos = calcBehind(camera.position, backDirection);

                // console.log(newPos.x, 'NEW POS X');
                // console.log(newPos.y, 'NEW POS Y');
                // console.log(newPos.z, 'NEW POS Z');



                group.children[0].position.x = (backDirection.x);
                group.children[1].position.x = (backDirection.x);
                group.children[2].position.x = (backDirection.x - .4);
                group.children[3].position.x = (backDirection.x + .4);
                group.children[4].position.x = (backDirection.x + .4);
                group.children[5].position.x = (backDirection.x - .4);

                group.children[0].position.z = (backDirection.z);
                group.children[1].position.z = (backDirection.z);
                group.children[2].position.z = (backDirection.z);
                group.children[3].position.z = (backDirection.z);
                group.children[4].position.z = (backDirection.z);
                group.children[5].position.z = (backDirection.z);


                // group.children[0].lookAt(backDirection);
                // group.children[1].lookAt(backDirection);
                // group.children[2].lookAt(backDirection);
                // group.children[3].lookAt(backDirection);
                // group.children[4].lookAt(backDirection);
                // group.children[5].lookAt(backDirection);




                controls.getObject().position.y += (velocity.y * delta); // new behavior
                //group.children[0].position.y += (velocity.y * delta); // new behavior

                if (controls.getObject().position.y < 60) {

                    velocity.y = 0;
                    controls.getObject().position.y = 60;

                    canJump = true;

                }

            }

            prevTime = time;

            renderer.render(scene, camera);

        }




        const onKeyDown = function (event) {

            switch (event.code) {

                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;

                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;

                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;

                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;

                case 'Space':
                    if (canJump === true) velocity.y += 350;
                    canJump = false;
                    break;

            }

        };

        const onKeyUp = function (event) {

            switch (event.code) {

                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;

                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;

                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;

                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;

            }

        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);


        function render() {




            // camera.applyMatrix4(rotateY);
            //  camera.updateMatrixWorld();

            // raycaster.setFromCamera(pointer, camera);


            raycaster.set(camera.getWorldPosition(new THREE.Vector3), camera.getWorldDirection(new THREE.Vector3));
            //console.log('distance', calcDistance(camera.position, sphere));
            let distance = calcDistance(camera.position, sphere);

            sphere.scale.set(distance * .5, distance * .5, distance * .5);





            const intersections = raycaster.intersectObjects(worldItems, false);
            intersection = (intersections.length) > 0 ? intersections[0] : null;

            if (toggle > 0.001 && intersection !== null) {

                spheres[spheresIndex].position.copy(intersection.point);
                toggle = 0;

            }


            toggle += clock.getDelta();



            updateSize();
            requestAnimationFrame(render);

            const time = performance.now();

            const delta = time - previousTime;



            // We need to translate the object back to the origin before rotating it:
            rotateAboutWorldAxis(sun.bulbLight, new THREE.Vector3(0.0, 0.0, 1.0), turnSpeed * .005);
            rotateAboutWorldAxis(moon.bulbLight, new THREE.Vector3(0.0, 0.0, 1.0), turnSpeed * .005);
            checkPositions(sun, moon);



            // Rotate while we rotate:
            //moon.rotateX(turnSpeed * 0.1);

            // // If we're rotating the camera change that here.
            // if (animateRotation)
            //     // The applyAxisAngle method rotates about an axis in space
            //     camera.position.applyAxisAngle(new THREE.Vector3(0.0, 1.0, 0.0), turnSpeed * 0.1);
            // if (animateOtherRotation)
            //     camera.position.applyAxisAngle(new THREE.Vector3(0.0, 0.0, 1.0), turnSpeed * 0.1);

            // camera.lookAt(new THREE.Vector3(xLookAt, yLookAt, zLookAt));

            // requestAnimationFrame(animate);
            // renderer.render(scene, camera);

            previousTime = time;
            renderer.render(scene, camera);
        }


        //source: https://threejs.org/examples/webgl_multiple_views.html
        //This function updates the window width and height variables to the actual width and height of the computer
        //regardless of whether the console has been opened or not
        function updateSize() {
            if (windowWidth != window.innerWidth || windowHeight != window.innerHeight) { //If the window width or height has
                //actually been changed than this if statement is triggered
                windowWidth = window.innerWidth;
                windowHeight = window.innerHeight;
                renderer.setSize(windowWidth, windowHeight);
            }
        }



        // function keyHandler(e) {
        //     switch (e.keyCode) {
        //         case 65: //L
        //             break;
        //         case 68:

        //             break;
        //         case 80:

        //             break;
        //         case 83:




        //     }
        // }






        // document.addEventListener("keydown", keyHandler, false);




        // raycaster.setFromCamera(pointer, camera);

        // const intersects = raycaster.intersectObjects(scene.children, false);

        // console.log(intersects);

        // if (intersects.length > 0) {

        //     if (INTERSECTED != intersects[0].object) {

        //         if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);

        //         INTERSECTED = intersects[0].object;
        //         INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
        //         INTERSECTED.material.emissive.setHex(0xff0000);

        //     }

        // } else {

        //     if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);

        //     INTERSECTED = null;

        // }














        animate();
        render();
    </script>
</body>

</html>