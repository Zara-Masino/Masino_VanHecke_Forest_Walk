<html>

<!-- Zara Masino & Brianna Van Hecke -->
<!--  For our "above and beyond feature, we added particle explosion" -->
<!--  For our rasterization technique, we added blending -->

<head>
    <title>3D Objects in Space</title>
</head>

<body>

    <canvas id="myCanvas" width="800" height="800"></canvas>



    <script type="module">

        //This imports the THREE library and the PointerLockControls from the school's website
        import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
        import { PointerLockControls } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/controls/PointerLockControls.js';


        //Variable Declarations
        let renderer;
        let hasShader;
        let tdelta = 0;
        const left = Math.floor(window.innerWidth * 0.0);
        const bottom = Math.floor(window.innerHeight * .05);
        const width = Math.floor(window.innerWidth * .7);
        const height = Math.floor(window.innerHeight * 1.0);
        let windowWidth, windowHeight;
        //Variable declarations for the particles
        let movementSpeeds = 40;
        let totalObjects = 500;
        let objectSize = 10;
        let colors = [0xFF0FFF, 0xCCFF00, 0xFF000F, 0x996600, 0xFFFFFF, 0xcbbeb5, 0x9003ff, 0x6d9bc3,
            0x87a96b, 0x520520, 0xeaa315, 0x327572, 0xb8888d, 0xcc77dd, 0xbcd4e6, 0xfe6f5e, 0x318ce7, 0xa2a2d0];
        let dirs = [];
        let parts = [];
        let direction = new THREE.Vector3();
        let backDirection = new THREE.Vector3();
        let index;
        //Other variables
        let prevTime = performance.now();
        let objects = [];
        let speed = 50;
        let scene = new THREE.Scene();


        let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.y = 10;
        camera.lookAt(0, 0, 0);

        //source: https://threejs.org/examples/webgl_multiple_views.html
        //This creates a JSON object which specifies the different cameras and the views & background colors
        //for each camera


        //This function initializes the renderer and the scene for the multiple viewports
        function initScene() {
            renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });//Creates a renderer and adds the canvass
            //to the renderer
            renderer.setClearColor(0x000000);
            // Sets the color for the renderer and makes it black
            renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio); //Sets the renderer's pixel ratio to
            //the pixel ratio of the canvas
            renderer.setSize(window.innerWidth, window.innerHeight); //Sets the size of the renderer to the entirety of the
            //Window height and width
        }

        //source: https://threejs.org/examples/webgl_multiple_views.html
        //This function updates the window width and height variables to the actual width and height of the computer
        //regardless of whether the console has been opened or not
        function updateSize() {
            if (windowWidth != window.innerWidth || windowHeight != window.innerHeight) { //If the window width or height has
                //actually been changed than this if statement is triggered
                windowWidth = window.innerWidth;
                windowHeight = window.innerHeight;
                renderer.setSize(windowWidth, windowHeight);
            }
        }

        initScene(); //Creates the renderers for eachcamera

        //Adds pointerlock controls to the camera
        var controls = new PointerLockControls(camera, document.body);

        //source: https://threejs.org/examples/webgl_multiple_views.html
        function render() {
            updateSize(); //Resizes window width and height if needws
            //Iterates through the different view objects

            renderer.render(scene, camera); //Renders the scene with specified cameras

        }

        //When the user clicks then the pointer controls lock into place and become enabled
        document.addEventListener('click', function () {
            controls.lock();
        });

        //This function randomly returns a true or false value or a number between 0 and 10 in order to help randomize certain customizations
        function random(type) {
            let randomNumber = Math.round(Math.random() * 10); //Creates a random number between 0 and 10
            if (type == 0) { //If the type passed in is 0
                if (randomNumber % 2 == 0) { //If the random number is even
                    return true;
                }
                else {
                    return false;
                }
            }
            else if (type == 1) { //If the type was 1 then return the random number
                return randomNumber;
            }
        }

        //This function makes either a shader material or customized material that involves blending
        function makeMaterial() {
            //Otherwise it creates a material that has blending functionality
            var material = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff });
            material.blending = THREE.CustomBlending; //Add cuustomized blending to material
            material.blendEquation = THREE.MaxEquation; //default
            return material;
        }




        //This function calculates and returns a randomized speed within certain bounds
        function movementSpeed(constant) {
            var speed = Math.random() * constant; //Creates a random number for the speed
            if (random(0) == false) { //If the random function returns false
                speed *= -1; //Make it negative
            }
            return speed; //Returns speed
        }

        //Piece function creates and customizes piece objects which will be added to the scene
        function Piece(shape) {
            //Randomizes whether or not the object will rotate on the x,y & z axis
            this.rotateOnXAxis = random(0);
            if (this.rotateOnXAxis == true) {
                this.rotateXSpeed = movementSpeed(.12); //Randomize a speed for the object's x rotation
            }
            this.rotateOnYAxis = random(0);
            if (this.rotateOnYAxis == true) {
                this.rotateYSpeed = movementSpeed(.12);//Randomize a speed for the object's y rotation
            }
            this.rotateOnZAxis = random(0);
            if (this.rotateOnZAxis == true) {
                this.rotateZSpeed = movementSpeed(.12);//Randomize a speed for the object's z rotation
            }
            this.verticalMovement = random(0);
            if (this.verticalMovement == true) {
                this.verticalSpeed = movementSpeed(2);//Randomize a speed for the object's vertical movement
            }
            this.horizontalMovement = random(0);
            if (this.horizontalMovement == true) {
                this.horizontalSpeed = movementSpeed(2);//Randomize a speed for the object's horizontal movement
            }
            this.depthMovement = random(0);
            if (this.depthMovement == true) {
                this.depthSpeed = movementSpeed(2);//Randomize a speed for the object's z axis movement
            }

            // Set up for all of the geometries
            this.create = function () {
                if (shape == true) { //If a random number is true then enter this if statement
                    let x, y, z;
                    if (random(1) > 8) { //If a random number is greater than 8 then enter this if statement
                        //and make a perfect sphere
                        let w = Math.random() * 50 + 5;
                        x = Math.random() * 20 + 5;
                        y = w;
                        z = w;
                    }
                    else { //Otherwise, randomize each of the parameters that make up a sphere
                        x = Math.random() * 20 + 5;
                        y = Math.random() * 3 + 3;
                        z = Math.random() * 3 + 3;
                    }
                    var geometry = new THREE.SphereGeometry(x, y, z); //Create sphere geometries
                    geometry.computeFaceNormals(); //Compute normals
                    this.object = new THREE.Mesh(geometry, makeMaterial()); //Create a material for the geometry and
                    //set it to a property of the piece function
                }
                else if (shape == false) { //Otherwise make a box geometry
                    let x, y, z;
                    if (random(1) > 7) { //If a randomoly generated number is greater than 7
                        let w = Math.random() * 40 + 10; //Make a perfect box
                        x = w;
                        y = w;
                        z = w;
                    }
                    else { //Otherwise make a box with randomized parameters
                        x = Math.random() * 40 + 10;
                        y = Math.random() * 40 + 10;
                        z = Math.random() * 40 + 10;
                    }
                    let boxGeometry = new THREE.BoxGeometry(x, y, z); //Create a box geometry
                    this.object = new THREE.Mesh(boxGeometry, makeMaterial()); //Create a new material for the box geomtry
                    //and set that mesh to a property of the function
                }
                //Set the object's position within some bounds of the camera's position
                this.object.position.x = (Math.random() * (camera.position.x + 200) - (camera.position.x - 200)) + (camera.position.x - 10);
                this.object.position.y = (Math.random() * (camera.position.y + 200) - (camera.position.y - 200)) + (camera.position.y - 10);
                this.object.position.z = (Math.random() * (camera.position.z + 200) - (camera.position.z + 200)) + (camera.position.z - 10);
                this.object.geometry.computeBoundingSphere(); //Compute a bounding sphere around each object
                //and set it as a property of the piece function
                scene.add(this.object); //Add the object to the scene
            }
        }



        //This function creates a specified number of objects which will be placed in the scene
        function initObjects(x) {
            for (let i = 0; i < x; i++) { //Iterates for a specified number of times
                let shape = new Piece(random(0)); //Creates a piece object based on the random function
                objects.push(shape);//Adds the object to the objects array
                shape.create(); //Actually customizes and places the object
            }
        }

        //Creates a new random coordinate based on a minimum and maximum
        function makeCoord(max, min) {
            let randomNumber = (Math.random() * max) + min; //Randomly generates a number
            if (random(0) == true) { //If the random function returns true
                randomNumber *= -1; //Make the randomly generated number negative
            }
            return randomNumber;
        }



        //https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_collision_detection
        //The above link helped us with determining the equation we would use to calculate the distance between two
        //points
        //Calculates the distance between two points
        function calcDistance(point, shape) {
            //This calculates the distance of two points based on the distance formula
            const distance = Math.sqrt(
                (point.x - shape.object.position.x) * (point.x - shape.object.position.x) +
                (point.y - shape.object.position.y) * (point.y - shape.object.position.y) +
                (point.z - shape.object.position.z) * (point.z - shape.object.position.z)
            )
            return distance; //Returns distance
        }



        //Function which detects whether the camera has collided with an object and then provides
        //some functionality to show that the collision was dealt with
        // function collisionDetection(point, shape) {
        //     let distance = calcDistance(point, shape); //Calculates the distance between the camera's position
        //     //and an object
        //     if (distance < shape.object.geometry.boundingSphere.radius) { //If the distance or camera is within the objects
        //         //bounding sphere
        //         parts.push(new ExplodeAnimation(shape.object.position.x, shape.object.position.y, shape.object.position.z));
        //         //Adds new explosion parts
        //         relocateShape(shape); //Relocates object to be within the camera's bounds but further away
        //         views[1].background = new THREE.Color(0.8, 0.8, 0.8); //Changes background color to white whenever you
        //         //hit an object
        //         speed = speed / 2; //Halfs the speed
        //         //source: https://www.freecodecamp.org/news/javascript-settimeout-how-to-set-a-timer-in-javascript-or-sleep-for-n-seconds/ 
        //         setTimeout(function () { //Wait for 300 milliseconds before you do the following
        //             views[1].background = new THREE.Color(0.0, 0.0, 0.0); //Set the background color back to black
        //             speed = speed * 2; //Set the speed back to its original state
        //         }, 300);
        //     }
        // }



        //The animate function is a function which is continuously called for every frame of the program
        function animate() {

            render(); //Calls render function



            //For loop iterates for every object in the objects array
            // for (let i = 0; i < objects.length; i++) {
            //     collisionDetection(views[1].camera.position, objects[i]); //Checks if the object collided with the camera
            //     tooFar(views[1].camera.position, objects[i]); //Checks if the object is too far from teh camera
            // }


            tdelta += 0.03; //Increment the tdelta value which will be used to grow/shrink specified objects continuously


            requestAnimationFrame(animate);

            https://threejs.org/examples/?q=pointer#misc_controls_pointerlock
            //The above link helped greatly with both delta time and with the pointer lock controls
            if (controls.isLocked === true) { //This if statement only occurs when the pointerlock control system is enabled
                const time = performance.now(); //This returns the value of time (of type double) in milliseconds
                const delta = (time - prevTime) / 1000; //This calculates delta time based on subtracting the current time a
                //frame was rendered from the last time a frame was rendered. Then we divide it by 1000

                camera.getWorldDirection(direction); //Gets the look at of the frontward facing camera

                //Customizes the movement of the camera in every axis so that it will always move by delta time multiplied
                //by some speed
                direction.x *= delta * speed;
                direction.y *= delta * speed;
                direction.z *= delta * speed;
                camera.position.add(direction); //Moves the camera in delta time

                prevTime = time; //Updates the last time the previous frame was calculated
            }
        }
        //Make and place objects
        initObjects(200);
        animate();

    </script>
</body>

</html>